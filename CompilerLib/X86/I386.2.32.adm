class I386
{
    static function Mov(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("mov", op1, op2);
    }

    static function MovR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("mov", op1, op2);
    }

    static function MovRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("mov", op1, op2);
    }

    static function MovAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("mov", op1, op2);
    }

    static function MovA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("mov", op1, op2);
    }

    static function Add(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("add", op1, op2);
    }

    static function AddR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("add", op1, op2);
    }

    static function AddRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("add", op1, op2);
    }

    static function AddAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("add", op1, op2);
    }

    static function AddA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("add", op1, op2);
    }

    static function Or(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("or", op1, op2);
    }

    static function OrR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("or", op1, op2);
    }

    static function OrRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("or", op1, op2);
    }

    static function OrAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("or", op1, op2);
    }

    static function OrA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("or", op1, op2);
    }

    static function Adc(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("adc", op1, op2);
    }

    static function AdcR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("adc", op1, op2);
    }

    static function AdcRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("adc", op1, op2);
    }

    static function AdcAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("adc", op1, op2);
    }

    static function AdcA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("adc", op1, op2);
    }

    static function Sbb(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("sbb", op1, op2);
    }

    static function SbbR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("sbb", op1, op2);
    }

    static function SbbRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("sbb", op1, op2);
    }

    static function SbbAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("sbb", op1, op2);
    }

    static function SbbA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("sbb", op1, op2);
    }

    static function And(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("and", op1, op2);
    }

    static function AndR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("and", op1, op2);
    }

    static function AndRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("and", op1, op2);
    }

    static function AndAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("and", op1, op2);
    }

    static function AndA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("and", op1, op2);
    }

    static function Sub(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("sub", op1, op2);
    }

    static function SubR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("sub", op1, op2);
    }

    static function SubRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("sub", op1, op2);
    }

    static function SubAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("sub", op1, op2);
    }

    static function SubA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("sub", op1, op2);
    }

    static function Xor(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("xor", op1, op2);
    }

    static function XorR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("xor", op1, op2);
    }

    static function XorRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("xor", op1, op2);
    }

    static function XorAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("xor", op1, op2);
    }

    static function XorA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("xor", op1, op2);
    }

    static function Cmp(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("cmp", op1, op2);
    }

    static function CmpR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("cmp", op1, op2);
    }

    static function CmpRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("cmp", op1, op2);
    }

    static function CmpAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("cmp", op1, op2);
    }

    static function CmpA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("cmp", op1, op2);
    }

    static function Test(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("test", op1, op2);
    }

    static function TestR(op1 : Reg32, op2 : Val32) : OpCode
    {
        return FromName2R("test", op1, op2);
    }

    static function TestRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return TestAR(op2, op1);
    }

    static function TestAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return FromName2AR("test", op1, op2);
    }

    static function TestA(op1 : Addr32, op2 : Val32) : OpCode
    {
        return FromName2A("test", op1, op2);
    }

    static function Xchg(op1 : Reg32, op2 : Reg32) : OpCode
    {
        return FromName2("xchg", op1, op2);
    }

    static function XchgRA(op1 : Reg32, op2 : Addr32) : OpCode
    {
        return FromName2RA("xchg", op1, op2);
    }

    static function XchgAR(op1 : Addr32, op2 : Reg32) : OpCode
    {
        return XchgRA(op2, op1);
    }

    static function GetOperatorCode(op : string) : int
    {
        switch (op)
        {
        case "add":
            return 0;
        case "or":
            return 1;
        case "adc":
            return 2;
        case "sbb":
            return 3;
        case "and":
            return 4;
        case "sub":
            return 5;
        case "xor":
            return 6;
        case "cmp":
            return 7;
        }
        return  - 1;
    }

    static function FromName2(op : string, op1 : Reg32, op2 : Reg32) : OpCode
    {
        byte b;
        int code;
        switch (op)
        {
        case "mov":
            b = 0x89;
            break;
        case "test":
            b = 0x85;
            break;
        case "xchg":
            if (op1 == Reg32.EAX)
                return OpCode.NewBytes(Util.GetBytes1((byte)(0x90 + op2)));
            else if (op2 == Reg32.EAX)
                return OpCode.NewBytes(Util.GetBytes1((byte)(0x90 + op1)));
            else
                b = 0x87;
            break;
        default:
            code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            b = (byte)(code * 8 + 1);
            break;
        }
        return OpCode.NewBytes(Util.GetBytes2(b, (byte)(0xc0 + (((int )op2) << 3) + op1)));
    }

    static function FromName2R(op : string, op1 : Reg32, op2 : Val32) : OpCode
    {
        var bytes : byte[];
        int code;
        switch (op)
        {
        case "mov":
            bytes = Util.GetBytes1((byte)(0xb8 + op1));
            break;
        case "test":
            if (op1 == Reg32.EAX)
                bytes = Util.GetBytes1(0xa9);
            else
                bytes = Util.GetBytes2(0xf7, (byte)(0xc0 + op1));
            break;
        default:
            code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            if (op1 == Reg32.EAX)
                bytes = Util.GetBytes1((byte)(code * 8 + 5));
            else
                bytes = Util.GetBytes2(0x81, (byte)(code * 8 + 0xc0 + op1));
            break;
        }
        return OpCode.NewD(bytes, op2);
    }

    static function FromName2RA(op : string, op1 : Reg32, op2 : Addr32) : OpCode
    {
        byte b;
        int code;
        switch (op)
        {
        case "mov":
            if (op1 == Reg32.EAX && op2.IsAddress)
                return OpCode.NewD(Util.GetBytes1(0xa1), op2.Address);
            b = 0x8b;
            break;
        case "xchg":
            b = 0x87;
            break;
        default:
            code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            b = (byte)(code * 8 + 3);
            break;
        }
        return OpCode.NewA(Util.GetBytes1(b), Addr32.NewAdM(op2, (byte)op1));
    }

    static function FromName2AR(op : string, op1 : Addr32, op2 : Reg32) : OpCode
    {
        byte b;
        int code;
        switch (op)
        {
        case "mov":
            if (op2 == Reg32.EAX && op1.IsAddress)
                return OpCode.NewD(Util.GetBytes1(0xa3), op1.Address);
            b = 0x89;
            break;
        case "test":
            b = 0x85;
            break;
        default:
            code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            b = (byte)(code * 8 + 1);
            break;
        }
        return OpCode.NewA(Util.GetBytes1(b), Addr32.NewAdM(op1, (byte)op2));
    }

    static function FromName2A(op : string, op1 : Addr32, op2 : Val32) : OpCode
    {
        int code;
        switch (op)
        {
        case "mov":
            return OpCode.NewDA(Util.GetBytes1(0xc7), op2, op1);
        case "test":
            return OpCode.NewDA(Util.GetBytes1(0xf7), op2, op1);
        default:
            code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            return OpCode.NewDA(Util.GetBytes1(0x81), op2, Addr32.NewAdM(op1, (byte)code));
        }
    }
}
