class I386
{
    static function MovB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("mov", op1, op2);
    }

    static function MovBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("mov", op1, op2);
    }

    static function MovBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("mov", op1, op2);
    }

    static function MovBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("mov", op1, op2);
    }

    static function MovBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("mov", op1, op2);
    }

    static function AddB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("add", op1, op2);
    }

    static function AddBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("add", op1, op2);
    }

    static function AddBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("add", op1, op2);
    }

    static function AddBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("add", op1, op2);
    }

    static function AddBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("add", op1, op2);
    }

    static function OrB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("or", op1, op2);
    }

    static function OrBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("or", op1, op2);
    }

    static function OrBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("or", op1, op2);
    }

    static function OrBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("or", op1, op2);
    }

    static function OrBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("or", op1, op2);
    }

    static function AdcB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("adc", op1, op2);
    }

    static function AdcBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("adc", op1, op2);
    }

    static function AdcBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("adc", op1, op2);
    }

    static function AdcBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("adc", op1, op2);
    }

    static function AdcBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("adc", op1, op2);
    }

    static function SbbB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("sbb", op1, op2);
    }

    static function SbbBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("sbb", op1, op2);
    }

    static function SbbBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("sbb", op1, op2);
    }

    static function SbbBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("sbb", op1, op2);
    }

    static function SbbBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("sbb", op1, op2);
    }

    static function AndB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("and", op1, op2);
    }

    static function AndBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("and", op1, op2);
    }

    static function AndBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("and", op1, op2);
    }

    static function AndBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("and", op1, op2);
    }

    static function AndBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("and", op1, op2);
    }

    static function SubB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("sub", op1, op2);
    }

    static function SubBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("sub", op1, op2);
    }

    static function SubBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("sub", op1, op2);
    }

    static function SubBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("sub", op1, op2);
    }

    static function SubBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("sub", op1, op2);
    }

    static function XorB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("xor", op1, op2);
    }

    static function XorBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("xor", op1, op2);
    }

    static function XorBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("xor", op1, op2);
    }

    static function XorBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("xor", op1, op2);
    }

    static function XorBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("xor", op1, op2);
    }

    static function CmpB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("cmp", op1, op2);
    }

    static function CmpBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("cmp", op1, op2);
    }

    static function CmpBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("cmp", op1, op2);
    }

    static function CmpBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("cmp", op1, op2);
    }

    static function CmpBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("cmp", op1, op2);
    }

    static function TestB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("test", op1, op2);
    }

    static function TestBR(op1 : Reg8, op2 : byte) : OpCode
    {
        return FromName2BR("test", op1, op2);
    }

    static function TestBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return TestBAR(op2, op1);
    }

    static function TestBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return FromName2BAR("test", op1, op2);
    }

    static function TestBA(op1 : Addr32, op2 : byte) : OpCode
    {
        return FromName2BA("test", op1, op2);
    }

    static function XchgB(op1 : Reg8, op2 : Reg8) : OpCode
    {
        return FromName2B("xchg", op1, op2);
    }

    static function XchgBRA(op1 : Reg8, op2 : Addr32) : OpCode
    {
        return FromName2BRA("xchg", op1, op2);
    }

    static function XchgBAR(op1 : Addr32, op2 : Reg8) : OpCode
    {
        return XchgBRA(op2, op1);
    }

    static function FromName2B(op : string, op1 : Reg8, op2 : Reg8) : OpCode
    {
        byte b;
        switch (op)
        {
        case "mov":
            b = 0x88;
            break;
        case "test":
            b = 0x84;
            break;
        case "xchg":
            b = 0x86;
            break;
        default:
            int code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            b = (byte)(code * 8);
            break;
        }
        return OpCode.NewBytes(Util.GetBytes2(b, (byte)(0xc0 + (((int )op2) << 3) + op1)));
    }

    static function FromName2BR(op : string, op1 : Reg8, op2 : byte) : OpCode
    {
        var bytes : byte[];
        switch (op)
        {
        case "mov":
            bytes = Util.GetBytes1((byte)(0xb0 + op1));
            break;
        case "test":
            if (op1 == Reg8.AL)
                bytes = Util.GetBytes1(0xa8);
            else
                bytes = Util.GetBytes2(0xf6, (byte)(0xc0 + op1));
            break;
        default:
            int code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            if (op1 == Reg8.AL)
                bytes = Util.GetBytes1((byte)(code * 8 + 4));
            else
                bytes = Util.GetBytes2(0x80, (byte)(code * 8 + 0xc0 + op1));
            break;
        }
        return OpCode.NewB(bytes, op2);
    }

    static function FromName2BRA(op : string, op1 : Reg8, op2 : Addr32) : OpCode
    {
        byte b;
        switch (op)
        {
        case "mov":
            if (op1 == Reg8.AL && op2.IsAddress)
                return OpCode.NewD(Util.GetBytes1(0xa0), op2.Address);
            b = 0x8a;
            break;
        case "xchg":
            b = 0x86;
            break;
        default:
            int code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            b = (byte)(code * 8 + 2);
            break;
        }
        return OpCode.NewA(Util.GetBytes1(b), Addr32.NewAdM(op2, (byte)op1));
    }

    static function FromName2BAR(op : string, op1 : Addr32, op2 : Reg8) : OpCode
    {
        byte b;
        switch (op)
        {
        case "mov":
            if (op2 == Reg8.AL && op1.IsAddress)
                return OpCode.NewD(Util.GetBytes1(0xa2), op1.Address);
            b = 0x88;
            break;
        case "test":
            b = 0x84;
            break;
        default:
            int code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            b = (byte)(code * 8);
            break;
        }
        return OpCode.NewA(Util.GetBytes1(b), Addr32.NewAdM(op1, (byte)op2));
    }

    static function FromName2BA(op : string, op1 : Addr32, op2 : byte) : OpCode
    {
        switch (op)
        {
        case "mov":
            return OpCode.NewBA(Util.GetBytes1(0xc6), op2, op1);
        case "test":
            return OpCode.NewBA(Util.GetBytes1(0xf6), op2, op1);
        default:
            int code = GetOperatorCode(op);
            if (code < 0)
                raise("invalid operator: " + op);
            return OpCode.NewBA(Util.GetBytes1(0x80), op2, Addr32.NewAdM(op1, (byte)code));
        }
    }
}
