class OpCode
{
    var Address : Val32 = Val32.NewI(0);
    var data : byte[];
    var op1 : object;
    var op2 : object;
    bool relative;

    bool _ByteRelative;
    function get_ByteRelative : bool { return _ByteRelative; }
    function set_ByteRelative(value : bool) { _ByteRelative = value; }

    static function NewBytes(d : byte[]) : OpCode
    {
        var ret = new OpCode();
        ret.data = d;
        return ret;
    }

    static function NewString(text : string) : OpCode
    {
        var ret = new OpCode();
        ret.data = getASCIIBytes(text);
        return ret;
    }

    static function New(d : byte[], op : object) : OpCode
    {
        var ret = new OpCode();
        ret.data = d;
        ret.op1 = op;
        return ret;
    }

    static function NewA(d : byte[], op : object, mem : Addr32) : OpCode
    {
        var ret = new OpCode();
        ret.data = d;
        ret.op1 = op;
        ret.op2 = mem;
        return ret;
    }

    static function NewB(d : byte[], op1 : object, op2 : byte) : OpCode
    {
        var ret = new OpCode();
        ret.data = d;
        ret.op1 = op1;
        ret.op2 = op2;
        return ret;
    }

    static function NewV(d : byte[], op : Val32, rel : bool) : OpCode
    {
        var ret = new OpCode();
        ret.data = d;
        ret.op1 = op;
        ret.relative = rel;
        return ret;
    }

    function Set(src : OpCode)
    {
        data = src.data;
        op1 = src.op1;
        op2 = src.op2;
        relative = src.relative;
    }

    function GetCodes()
    {
        var data = this.data;
        if (this.op2 is Addr32)
            data = Util.Concat(data, (op2 as Addr32).GetCodes());
        if (this.op1 == null)
            return data;
        if (this.op1 is byte)
            data = Util.AddByteToBytes(data, (byte)op1);
        else if (this.op1 is ushort)
            data = Util.AddUShortToBytes(data, (ushort)op1);
        else if (this.op1 is Val32)
        {
            uint val = ((Val32)op1).Value;
            if (ByteRelative)
            {
                val -= Address.Value + (uint)data.Length + 1;
                data = Util.AddByteToBytes(data, (byte)val);
            }
            else
            {
                if (relative)
                    val -= Address.Value + (uint)data.Length + 4;
                data = Util.AddUIntToBytes(data, val);
            }
        }
        else
        {
            raise("The method or operation is not implemented.");
        }
        if (this.op2 is byte)
            data = Util.Concat(data, Util.GetBytes1((byte)op2));
        return data;
    }

    function Write(block : Block)
    {
        if (this.op1 is Val32 && relative)
        {
            block.AddBytes(GetCodes());
        }
        else if (data != null)
        {
            block.AddBytes(data);
            if (this.op2 is Addr32)
                (op2 as Addr32).Write(block);
            if (op1 != null)
            {
                if (this.op1 is byte)
                    block.AddByte((byte)op1);
                else if (this.op1 is ushort)
                    block.AddUShort((ushort)op1);
                else if (this.op1 is Val32)
                    block.AddVal32((Val32)op1);
                else
                    raise("The method or operation is not implemented.");
            }
            if (this.op2 is byte)
                block.AddByte((byte)op2);
        }
    }

    function Test(mnemonic : string, data : string)
    {
        var datastr = BitConverter.ToString(GetCodes());
        if (data != datastr)
        {
            raise(string.Format("[Test 1 failed] %s\r\n\tOK: %s\r\n\tNG: %s", mnemonic, data, datastr));
        }
        var block = new Block();
        Write(block);
        var datastr2 = BitConverter.ToString(block.ToByteArray());
        if (data != datastr2)
        {
            raise(string.Format("[Test 2 failed] %s\r\n\tOK: %s\r\n\tNG: %s", mnemonic, data, datastr2));
        }
    }
}
