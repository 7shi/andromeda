const int WINDOWS_GUI   = 2;
const int WINDOWS_CUI   = 3;
const int WINCE_GUI     = 9;
const int MACHINE_I386  = 0x014c;
const int MACHINE_X8664 = 0x8664;
const int MACHINE_ARM   = 0x01c0;

class PEModule
{
	PEFileHeader File;
	PEHeaderStandardFields Std;
	PEHeaderWindowsNTSpecificFields WinNT;
	PEHeaderDataDirectories Dir;
	SectionHeader Text;
	SectionHeader RData;
	SectionHeader IData;
	
	var rdata = new Block;
	var imports = new ImportSection;
	
	function ctor
	{
		File.NumberOfSections = 3;
		Text .Name = ".text";
		RData.Name = ".rdata";
		IData.Name = ".idata";
		Text .Characteristics = 0x60000060;
		RData.Characteristics = 0x40000040;
		IData.Characteristics = 0xc0000040;
	}
	
	function SetAddress
	{
		Text .SizeOfRawData = Align(Text .VirtualSize, WinNT.FileAlignment);
		RData.SizeOfRawData = Align(RData.VirtualSize, WinNT.FileAlignment);
		IData.SizeOfRawData = Align(IData.VirtualSize, WinNT.FileAlignment);
		
		Text .PointerToRawData = Align(0x80 + sizeof(PEModule), WinNT.FileAlignment);
		RData.PointerToRawData = Text .PointerToRawData + Text .SizeOfRawData;
		IData.PointerToRawData = RData.PointerToRawData + RData.SizeOfRawData;
		
		Text .VirtualAddress = WinNT.SectionAlignment;
		RData.VirtualAddress = Text .VirtualAddress + Align(Text .VirtualSize, WinNT.SectionAlignment);
		IData.VirtualAddress = RData.VirtualAddress + Align(RData.VirtualSize, WinNT.SectionAlignment);
		WinNT.ImageSize = IData.VirtualAddress + Align(IData.VirtualSize, WinNT.SectionAlignment);
		
		Std.BaseOfCode = Text.VirtualAddress;
		Std.CodeSize   = Text.VirtualSize;
		Std.BaseOfData = RData.VirtualAddress;
		Std.InitializedDataSize = RData.VirtualSize;
		Dir.ImportTable_Address = IData.VirtualAddress;
		
		if (Std.EntryPoint < Text.VirtualAddress
			|| Std.EntryPoint >= Text.VirtualAddress + Text.VirtualSize)
		{
			Std.EntryPoint = Text.VirtualAddress;
		}
	}
	
	function get_RawSize
	{
		return IData.PointerToRawData + IData.SizeOfRawData;
	}
	
	function Link(text : Block)
	{
		Text .VirtualSize = text .Length;
		RData.VirtualSize = rdata.Length;
		IData.VirtualSize = imports.Length;
		SetAddress();
		text .Address = WinNT.ImageBase + Text .VirtualAddress;
		rdata.Address = WinNT.ImageBase + RData.VirtualAddress;
		var idata = imports.Create(this);
		
		var ret = new byte[RawSize];
		var bw = new BinaryWriter;
		bw.Init(ret, ret.Length);
		
		var peh_ad = 0x80;
		DOSHeader dosh;
		bw.WriteWithLength(dosh, sizeof dosh);
		bw.Position = 0x3c;
		bw.WriteInt(peh_ad);
		bw.Write(HexBin("0e1fba0e00b409cd21b8014ccd21"));
		bw.WriteByteString("This program cannot be run in DOS mode.\r\n$");
		bw.Position = peh_ad;
		bw.WriteByte('P');
		bw.WriteByte('E');
		bw.WriteShort(0);
		bw.WriteWithLength(File , sizeof File );
		bw.WriteWithLength(Std  , sizeof Std  );
		bw.WriteWithLength(WinNT, sizeof WinNT);
		bw.WriteWithLength(Dir  , sizeof Dir  );
		bw.WriteWithLength(Text , sizeof Text );
		bw.WriteWithLength(RData, sizeof RData);
		bw.WriteWithLength(IData, sizeof IData);
		
		bw.Position = Text.PointerToRawData;
		bw.Write(text.ToArray());
		bw.Position = RData.PointerToRawData;
		bw.Write(rdata.ToArray());
		bw.Position = IData.PointerToRawData;
		bw.Write(idata);
		
		return ret;
	}
	
	function Import(lib : string, sym : string)
	{
		return imports.Add(lib, sym);
	}
	
	var strings = new Hashtable;
	
	function GetString(s : string)
	{
		var ret = (Addr32)strings.Get(s);
		if (ret == null)
		{
			ret = rdata.CurrentAddress;
			rdata.AddString(s);
			rdata.AddShort(0);
			strings.Add(s, ret);
		}
		return ret;
	}
}

struct SectionHeader
{
	function get_Name
	{
		var buf = new byte[9];
		__movsb(buf, name, 8);
		return wstr(buf);
	}
	
	function set_Name(s : string)
	{
		for (int i = 0; i < 8; i++)
		{
			if (i < s.Length)
				name[i] = s[i];
			else
				name[i] = 0;
		}
	}
}

function ReadInt(p)
{
	return ((int*)p)[0];
}

function HexBin(hex : string)
{
	var ret = new byte[hex.Length >> 1];
	for (int i = 0; i < ret.Length; i++)
		ret[i] = ParseHexChar(hex[i * 2]) * 16
			+ ParseHexChar(hex[i * 2 + 1]);
	return ret;
}

function ParseHexChar(ch : char)
{
	if ('0' <= ch && ch <= '9') return ch - '0';
	if ('A' <= ch && ch <= 'F') return ch - 'A' + 10;
	if ('a' <= ch && ch <= 'f') return ch - 'a' + 10;
	return 0;
}

function Align(size, align)
{
	if (size == 0) return align;
	return (size + align - 1) / align * align;
}
