const int WINDOWS_GUI   = 2;
const int WINDOWS_CUI   = 3;
const int WINCE_GUI     = 9;
const int MACHINE_I386  = 0x014c;
const int MACHINE_X8664 = 0x8664;
const int MACHINE_ARM   = 0x01c0;

struct PEModule
{
	byte signature_1 = 'P';
	byte signature_2 = 'E';
	byte signature_3 = 0;
	byte signature_4 = 0;
	PEFileHeader File;
	PEHeaderStandardFields Std;
	PEHeaderWindowsNTSpecificFields WinNT;
	PEHeaderDataDirectories Dir;
	SectionHeader Text;
	SectionHeader RData;
	SectionHeader IData;
	
	function ctor
	{
		File.NumberOfSections = 3;
		Text .Name = ".text";
		RData.Name = ".rdata";
		IData.Name = ".idata";
		Text .Characteristics = 0x60000060;
		RData.Characteristics = 0x40000040;
		IData.Characteristics = 0xc0000040;
		SetAddress();
		Std.EntryPoint = Text.VirtualAddress;
	}
	
	function SetAddress
	{
		Text .SizeOfRawData = Align(Text .VirtualSize, WinNT.FileAlignment);
		RData.SizeOfRawData = Align(RData.VirtualSize, WinNT.FileAlignment);
		IData.SizeOfRawData = Align(IData.VirtualSize, WinNT.FileAlignment);
		
		Text .PointerToRawData = Align(0x80 + sizeof(PEModule), WinNT.FileAlignment);
		RData.PointerToRawData = Text .PointerToRawData + Text .SizeOfRawData;
		IData.PointerToRawData = RData.PointerToRawData + RData.SizeOfRawData;
		
		Text .VirtualAddress = WinNT.SectionAlignment;
		RData.VirtualAddress = Text .VirtualAddress + Align(Text .VirtualSize, WinNT.SectionAlignment);
		IData.VirtualAddress = RData.VirtualAddress + Align(RData.VirtualSize, WinNT.SectionAlignment);
		WinNT.ImageSize = IData.VirtualAddress + Align(IData.VirtualSize, WinNT.SectionAlignment);
		
		Std.BaseOfCode = Text.VirtualAddress;
		Std.CodeSize   = Text.VirtualSize;
		Std.BaseOfData = RData.VirtualAddress;
		Std.InitializedDataSize = RData.VirtualSize;
		Dir.ImportTable_Address = IData.VirtualAddress;
		Dir.ImportTable_Size    = IData.VirtualSize;
	}
	
	function get_RawSize
	{
		return IData.PointerToRawData + IData.SizeOfRawData;
	}
	
	function Link(text : byte[], rdata : byte[], isec : ImportSection)
	{
		var idata = isec.Create();
		Text .VirtualSize = text .Length;
		RData.VirtualSize = rdata.Length;
		IData.VirtualSize = idata.Length;
		SetAddress();
		
		var ret = new byte[RawSize];
		var bw = new BinaryWriter;
		bw.Init(ret, ret.Length);
		
		var peh_ad = 0x80;
		DOSHeader dosh;
		bw.WriteWithLength(dosh, sizeof dosh);
		bw.Position = 0x3c;
		bw.WriteInt(peh_ad);
		bw.Write(HexBin("0e1fba0e00b409cd21b8014ccd21"));
		bw.WriteByteString("This program cannot be run in DOS mode.\r\n$");
		bw.Position = peh_ad;
		bw.WriteWithLength(this, sizeof PEModule);
		
		bw.Position = Text.PointerToRawData;
		bw.Write(text);
		bw.Position = RData.PointerToRawData;
		bw.Write(rdata);
		bw.Position = IData.PointerToRawData;
		bw.Write(idata);
		
		return ret;
	}
}

struct SectionHeader
{
	function get_Name
	{
		var buf = new byte[9];
		__movsb(buf, name, 8);
		return cstr(buf);
	}
	
	function set_Name(s : string)
	{
		for (int i = 0; i < 8; i++)
		{
			if (i < s.Length)
				name[i] = s[i];
			else
				name[i] = 0;
		}
	}
}

class ImportSection
{
	ImportTable table;
	var DLL : string;
	var symbols = new StringList;
	
	function Add(symbol : string)
	{
		symbols.Add(symbol);
	}
	
	function SetAddress(pem : PEModule)
	{
		var size = (symbols.Count + 1) * sizeof(var);
		table.ImportLookupTable = pem.IData.VirtualAddress + sizeof(ImportTable) * 2;
		table.ImportAddressTable = table.ImportLookupTable + size;
		table.Name = table.ImportAddressTable + size;
	}
	
	function Create
	{
		var ms = new MemoryStream;
		ms.WriteWithLength(table, sizeof table);
		ms.Write(new byte[sizeof table]);
		var dll = cstr(DLL);
		var padlen = Align(dll.Length + 1, 2);
		ms.WriteInt(table.Name + padlen);
		ms.WriteInt(0);
		ms.WriteInt(table.Name + padlen);
		ms.WriteInt(0);
		ms.Write(dll);
		ms.Write(new byte[padlen - dll.Length]);
		ms.WriteShort(0);
		for (int i = 0; i < symbols.Count; i++)
		{
			ms.WriteByteString(symbols.Get(i));
			ms.WriteByte(0);
		}
		return ms.ToArray();
	}
}

function ReadInt(p)
{
	return ((int*)p)[0];
}

function HexBin(hex : string)
{
	var ret = new byte[hex.Length >> 1];
	for (int i = 0; i < ret.Length; i++)
		ret[i] = ParseHexChar(hex[i * 2]) * 16
			+ ParseHexChar(hex[i * 2 + 1]);
	return ret;
}

function ParseHexChar(ch : char)
{
	if ('0' <= ch && ch <= '9') return ch - '0';
	if ('A' <= ch && ch <= 'F') return ch - 'A' + 10;
	if ('a' <= ch && ch <= 'f') return ch - 'a' + 10;
	return 0;
}

function Align(size, align)
{
	if (size == 0) return align;
	return (size + align - 1) / align * align;
}
